# Технический Дизайн Исправления Ошибок Парсинга

## Обзор

Данный документ описывает технический подход к исправлению критических ошибок в парсерах недвижимости (Avito, Cian, Yandex Realty). Основная проблема заключается в небезопасном доступе к атрибутам HTML элементов, отсутствии проверок на None, слабых fallback механизмах и недостаточном логировании. Это приводит к падению парсеров при малейших изменениях в HTML структуре сайтов и потере данных даже когда большая часть элементов могла быть успешно обработана.

Стратегия исправления основана на принципе "fail gracefully" - парсер должен обрабатывать максимальное количество элементов, пропуская проблемные с детальным логированием, вместо полного падения при первой ошибке.

## Глоссарий

- **Bug_Condition (C)**: Условие, при котором проявляется ошибка - когда парсер обращается к атрибуту HTML элемента без проверки на существование или к методу None объекта
- **Property (P)**: Желаемое поведение при условии C - парсер должен безопасно обработать отсутствующий атрибут, залогировать проблему и продолжить обработку следующих элементов
- **Preservation**: Существующее поведение успешного парсинга корректно структурированного HTML, которое должно остаться неизменным
- **_parse_html**: Основной метод в `app/parsers/avito/parser.py` (строка 111), который извлекает данные из HTML и создает список PropertyCreate объектов
- **PropertyCreate**: Pydantic модель из `app/models/schemas.py`, представляющая объявление о недвижимости с валидацией полей
- **safe_get_attr**: Планируемая вспомогательная функция для безопасного извлечения атрибутов HTML элементов с fallback значениями
- **ParsingStatistics**: Планируемый класс для сбора и логирования статистики парсинга (найдено, обработано, пропущено)

## Детали Ошибки

### Условие Проявления Ошибки (Fault Condition)

Ошибка проявляется когда парсер пытается получить доступ к атрибутам или методам HTML элементов без предварительной проверки на существование. Функция `_parse_html` использует небезопасные паттерны доступа к данным, что приводит к исключениям KeyError, TypeError, AttributeError при малейших изменениях в HTML структуре.

**Формальная Спецификация:**
```
FUNCTION isBugCondition(input)
  INPUT: input типа (html_element, attribute_name, operation_type)
  OUTPUT: boolean
  
  RETURN (operation_type == "direct_attribute_access" AND attribute_name NOT IN html_element.attrs)
         OR (operation_type == "method_call" AND html_element IS None)
         OR (operation_type == "nested_access" AND ANY intermediate_value IS None)
         OR (operation_type == "pydantic_validation" AND input_data IS invalid)
END FUNCTION
```

### Примеры

- **Пример 1**: `item["data-item-id"]` - если атрибут `data-item-id` отсутствует в элементе, выбрасывается KeyError и обработка всех последующих элементов прерывается. Ожидается: использовать `item.get("data-item-id")` с проверкой на None и пропустить элемент с логированием.

- **Пример 2**: `price_elem["content"]` - если `price_elem` равен None (селектор не нашел элемент), выбрасывается TypeError. Ожидается: проверить `if price_elem and price_elem.get("content")` и использовать fallback стратегии извлечения цены.

- **Пример 3**: `img["src"]` - если изображение использует lazy loading с атрибутом `data-src`, парсер не извлекает URL. Ожидается: проверять оба атрибута `img.get("src") or img.get("data-src")`.

- **Пример 4**: `PropertyCreate(**props)` - если данные невалидны (например, отрицательная цена), Pydantic выбрасывает ValidationError. Ожидается: обернуть создание объекта в try-except и залогировать детали валидационной ошибки.

## Ожидаемое Поведение

### Требования к Сохранению Существующего Поведения

**Неизменное Поведение:**
- Парсер должен продолжать создавать валидные PropertyCreate объекты с теми же полями при успешном извлечении всех данных из корректно структурированного HTML
- Извлечение количества комнат и площади из заголовка должно продолжать использовать существующие regex паттерны
- Методы `_extract_location` и `_extract_description` должны продолжать работать с той же логикой
- Ограничение количества фотографий до 5 должно сохраниться
- Преобразование относительных URL в абсолютные с использованием BASE_URL должно сохраниться
- Формат возвращаемого значения (список PropertyCreate объектов) должен остаться неизменным
- Использование BeautifulSoup с lxml парсером должно сохраниться
- Корректная конвертация цен в разных форматах (с пробелами, запятыми) в float должна сохраниться

**Область Действия:**
Все входные данные, которые НЕ содержат отсутствующие атрибуты, None элементы или невалидные данные, должны быть полностью не затронуты этим исправлением. Это включает:
- Корректно структурированный HTML с полным набором атрибутов
- Элементы с валидными данными во всех обязательных полях
- Успешные сценарии парсинга, которые работают в текущей версии

## Гипотеза о Первопричине

На основе анализа кода и описания ошибки, наиболее вероятные причины:

1. **Небезопасный Доступ к Атрибутам**: Код использует прямой доступ через квадратные скобки `item["attr"]` вместо безопасного метода `.get("attr")` с проверкой на None
   - В строке 148: `item["data-item-id"]` - прямой доступ без проверки
   - В строке 150: `price_elem["content"]` - доступ к атрибуту без проверки на None самого элемента
   - В строке 143: `link_elem["href"]` - доступ без проверки существования атрибута

2. **Отсутствие Проверок на None**: Код не проверяет, что селекторы нашли элементы перед обращением к их атрибутам
   - Проверка `if not all([title_elem, price_elem, link_elem])` на строке 124 недостаточна, так как после нее все равно используется небезопасный доступ к атрибутам

3. **Слабые Fallback Механизмы**: Отсутствуют альтернативные стратегии извлечения критических данных
   - Цена извлекается только из атрибута `content`, нет fallback на текст элемента или regex
   - Фотографии проверяются только по атрибуту `src`, игнорируя `data-src` для lazy loading

4. **Недостаточное Логирование**: Общий `except Exception as e: logger.error(f"Error parsing item: {e}")` на строке 157 не предоставляет деталей о том, какое поле вызвало ошибку
   - Нет логирования статистики (сколько элементов найдено, обработано, пропущено)
   - Нет предупреждений при изменении HTML структуры (когда селекторы не находят элементы)

5. **Отсутствие Валидации Перед Созданием Pydantic Объектов**: ValidationError от Pydantic не обрабатывается, что приводит к прерыванию обработки всех последующих элементов

## Свойства Корректности

Property 1: Fault Condition - Безопасная Обработка Отсутствующих Атрибутов

_Для любого_ HTML элемента, где условие ошибки выполняется (isBugCondition возвращает true), исправленная функция _parse_html ДОЛЖНА безопасно обработать отсутствующий атрибут или None элемент, залогировать детальную информацию о проблеме (имя поля, селектор, тип ошибки), пропустить проблемный элемент и продолжить обработку следующих элементов без прерывания всего процесса парсинга.

**Валидирует: Требования 2.1, 2.2, 2.3, 2.9**

Property 2: Preservation - Сохранение Успешного Парсинга

_Для любого_ HTML элемента, где условие ошибки НЕ выполняется (isBugCondition возвращает false), исправленная функция _parse_html ДОЛЖНА производить точно такой же результат, как и оригинальная функция, сохраняя все существующие методы извлечения данных, regex паттерны, ограничения и формат возвращаемых PropertyCreate объектов.

**Валидирует: Требования 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8**

## Реализация Исправления

### Необходимые Изменения

Предполагая, что наш анализ первопричины корректен:

**Файл**: `app/parsers/avito/parser.py`

**Функция**: `_parse_html` (строка 111)

**Конкретные Изменения**:

1. **Добавить Вспомогательные Функции для Безопасного Доступа**:
   - Создать функцию `_safe_get_attr(element, attr_name, default=None)` для безопасного извлечения атрибутов
   - Создать функцию `_safe_get_text(element, default="")` для безопасного извлечения текста
   - Создать класс `ParsingStatistics` для сбора статистики парсинга

2. **Улучшить Извлечение Обязательных Полей с Fallback Механизмами**:
   - `external_id`: использовать `item.get("data-item-id")` с проверкой на None, если отсутствует - пропустить элемент
   - `price`: реализовать многоуровневую стратегию - сначала `price_elem.get("content")`, затем текст элемента с regex, затем поиск альтернативных селекторов
   - `link`: использовать `link_elem.get("href")` с валидацией на пустую строку
   - `title`: добавить проверку на пустую строку после `.text.strip()`

3. **Улучшить Извлечение Фотографий**:
   - Проверять оба атрибута: `img.get("src") or img.get("data-src")`
   - Валидировать URL (не пустая строка, корректный формат)
   - Преобразовывать относительные URL в абсолютные

4. **Добавить Детальное Логирование**:
   - Логировать предупреждение, если основной селектор `[data-marker='item']` не находит элементы
   - Логировать детали для каждого пропущенного элемента: какое поле отсутствует, значение селектора
   - Логировать итоговую статистику: найдено X элементов, успешно обработано Y, пропущено Z

5. **Обернуть Создание PropertyCreate в Обработку ValidationError**:
   - Использовать `try-except` для перехвата ValidationError от Pydantic
   - Логировать детали валидационной ошибки (какие поля невалидны, их значения)
   - Продолжить обработку следующих элементов

6. **Применить Аналогичные Изменения к Другим Парсерам**:
   - `app/parsers/cian/parser.py` - метод `_parse_html` (строка 151)
   - `app/parsers/yandex_realty/parser.py` - если существует аналогичный метод

**Файл**: `app/parsers/base_parser.py` (опционально)

**Изменения**: Добавить базовые вспомогательные методы для безопасного доступа, которые могут быть переиспользованы всеми парсерами:
- `_safe_get_attr(element, attr_name, default=None)`
- `_safe_get_text(element, default="")`
- `_extract_price_with_fallback(price_elem, item)` - универсальная стратегия извлечения цены
- `_extract_photos_with_fallback(item, limit=5)` - универсальная стратегия извлечения фотографий

## Стратегия Тестирования

### Подход к Валидации

Стратегия тестирования следует двухфазному подходу: сначала выявить контрпримеры, демонстрирующие ошибку на неисправленном коде, затем проверить, что исправление работает корректно и сохраняет существующее поведение.

### Исследовательская Проверка Условия Ошибки

**Цель**: Выявить контрпримеры, демонстрирующие ошибку ДО реализации исправления. Подтвердить или опровергнуть анализ первопричины. Если опровергнем, потребуется пересмотреть гипотезу.

**План Тестирования**: Создать тестовые HTML фрагменты с отсутствующими атрибутами, None элементами и невалидными данными. Запустить эти тесты на НЕИСПРАВЛЕННОМ коде, чтобы наблюдать падения и понять первопричину.

**Тестовые Случаи**:
1. **Тест Отсутствующего data-item-id**: HTML элемент без атрибута `data-item-id` (упадет на неисправленном коде с KeyError)
2. **Тест Отсутствующего Элемента Цены**: HTML без элемента `[itemprop='price']` (упадет на неисправленном коде с TypeError при обращении к None)
3. **Тест Отсутствующего Атрибута href**: Элемент ссылки без атрибута `href` (упадет на неисправленном коде с KeyError)
4. **Тест Lazy Loading Изображений**: Изображения только с атрибутом `data-src` (не извлечет фотографии на неисправленном коде)
5. **Тест Невалидной Цены**: Элемент цены с нечисловым значением (упадет на неисправленном коде с ValueError)
6. **Тест ValidationError**: Данные с отрицательной ценой (упадет на неисправленном коде с ValidationError от Pydantic)
7. **Тест Пустого HTML**: HTML без элементов `[data-marker='item']` (вернет пустой список без предупреждения на неисправленном коде)

**Ожидаемые Контрпримеры**:
- KeyError при обращении к `item["data-item-id"]` когда атрибут отсутствует
- TypeError при обращении к `price_elem["content"]` когда price_elem равен None
- ValidationError при создании PropertyCreate с невалидными данными
- Потеря данных фотографий при использовании lazy loading
- Отсутствие логирования при изменении HTML структуры

### Проверка Исправления

**Цель**: Проверить, что для всех входных данных, где условие ошибки выполняется, исправленная функция производит ожидаемое поведение.

**Псевдокод:**
```
FOR ALL input WHERE isBugCondition(input) DO
  result := _parse_html_fixed(input)
  ASSERT result не содержит исключений
  ASSERT проблемный элемент пропущен
  ASSERT залогирована детальная информация о проблеме
  ASSERT обработка продолжилась для следующих элементов
END FOR
```

### Проверка Сохранения Поведения

**Цель**: Проверить, что для всех входных данных, где условие ошибки НЕ выполняется, исправленная функция производит тот же результат, что и оригинальная функция.

**Псевдокод:**
```
FOR ALL input WHERE NOT isBugCondition(input) DO
  ASSERT _parse_html_original(input) = _parse_html_fixed(input)
END FOR
```

**Подход к Тестированию**: Property-based тестирование рекомендуется для проверки сохранения поведения, потому что:
- Оно автоматически генерирует множество тестовых случаев по всему входному домену
- Оно выявляет граничные случаи, которые могут быть упущены в ручных unit тестах
- Оно предоставляет сильные гарантии, что поведение не изменилось для всех не-багованных входных данных

**План Тестирования**: Сначала наблюдать поведение на НЕИСПРАВЛЕННОМ коде для корректно структурированного HTML, затем написать property-based тесты, фиксирующие это поведение.

**Тестовые Случаи**:
1. **Сохранение Успешного Парсинга**: Наблюдать, что корректный HTML успешно парсится на неисправленном коде, затем проверить, что исправленный код производит идентичные PropertyCreate объекты
2. **Сохранение Извлечения Комнат и Площади**: Проверить, что regex паттерны продолжают работать одинаково
3. **Сохранение Методов _extract_location и _extract_description**: Проверить, что эти методы возвращают те же результаты
4. **Сохранение Ограничения Фотографий**: Проверить, что лимит в 5 фотографий применяется
5. **Сохранение Преобразования URL**: Проверить, что относительные URL преобразуются в абсолютные одинаково

### Unit Тесты

- Тест безопасного извлечения атрибутов с отсутствующими значениями
- Тест fallback механизма для извлечения цены (атрибут content → текст элемента → regex)
- Тест извлечения фотографий с поддержкой lazy loading (src и data-src)
- Тест валидации данных перед созданием PropertyCreate
- Тест логирования статистики парсинга
- Тест обработки пустого HTML
- Тест детального логирования ошибок с указанием проблемного поля

### Property-Based Тесты

- Генерировать случайные HTML фрагменты с различными комбинациями отсутствующих атрибутов и проверять, что парсер не падает
- Генерировать корректно структурированный HTML и проверять, что результаты идентичны оригинальной функции
- Генерировать HTML с различными форматами цен и проверять корректную конвертацию
- Тестировать, что все успешно обработанные элементы имеют валидные обязательные поля

### Integration Тесты

- Тест полного цикла парсинга с реальным HTML от Avito (сохраненный snapshot)
- Тест парсинга HTML с частично отсутствующими данными (некоторые элементы корректны, некоторые нет)
- Тест логирования статистики после завершения парсинга
- Тест применения исправления к другим парсерам (Cian, Yandex Realty)
